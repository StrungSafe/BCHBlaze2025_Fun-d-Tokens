pragma cashscript ~0.13.0;

// a brute forcy way but get it done first
// ideally the fund details could be more dynamic
contract MintingFund(bytes managerCategory, bytes redeemAsset1, bytes asset1, int amount1, bytes redeemAsset2, bytes asset2, int amount2) 
{
    function collect() {
        // we are able to spend back to the contract the proof of manager
        require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode);
        require(tx.inputs[this.activeInputIndex].tokenCategory == managerCategory);
        require(tx.inputs[this.activeInputIndex].tokenCategory == tx.outputs[this.activeInputIndex].tokenCategory);
        require(tx.inputs[this.activeInputIndex].nftCommitment == tx.outputs[this.activeInputIndex].nftCommitment);

        int outputIndex = 0;
        bool asset1Collected = false;
        bool asset2Collected = false;
        do {
            if(tx.outputs[outputIndex].lockingBytecode == redeemAsset1
                && tx.outputs[outputIndex].tokenCategory == asset1
                && tx.outputs[outputIndex].tokenAmount == amount1) {
                asset1Collected = true;
            }

            if(tx.outputs[outputIndex].lockingBytecode == redeemAsset2
                && tx.outputs[outputIndex].tokenCategory == asset2
                && tx.outputs[outputIndex].tokenAmount == amount2) {
                asset2Collected = true;
            }

            outputIndex = outputIndex + 1;
        } while(outputIndex < tx.outputs.length);
        require(asset1Collected);
        require(asset2Collected);
    }
}
